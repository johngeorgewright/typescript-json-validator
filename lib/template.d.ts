import Ajv = require('ajv');
import * as TJS from 'typescript-json-schema';
export declare type GENERATED_COMMENT = `// generated by typescript-json-validator`;
export declare const IMPORT_INSPECT = "import {inspect} from 'util';";
export declare const IMPORT_AJV = "import Ajv = require('ajv');";
export declare const IMPORT_KOA_CONTEXT = "import {Context} from 'koa';";
export declare const importNamedTypes: (
  names: string[],
  relativePath: string,
) => string;
export declare const importDefaultType: (
  name: string,
  relativePath: string,
) => string;
export declare const importType: (
  name: string,
  relativePath: string,
  {
    isNamedExport,
  }: {
    isNamedExport: boolean;
  },
) => string;
export declare const declareAJV: (options: Ajv.Options) => string;
export declare const exportNamed: (names: string[]) => string;
export declare const declareSchema: (
  name: string,
  schema: TJS.Definition,
) => string;
export declare const addSchema: (name: string) => string;
export declare const DECLARE_VALIDATE_TYPE =
  "export type ValidateFunction<T> = ((data: unknown) => data is T) & Pick<Ajv.ValidateFunction, 'errors'>";
export declare const validateType: (typeName: string) => string;
export declare const compileSchema: (
  schemaName: string,
  typeName: string,
) => string;
export declare const validateFn: (
  typeName: string,
  schemaName: string,
) => string;
export declare const validateKoaRequestOverload: (
  typeName: string,
  schema: TJS.Definition,
) => string;
export declare const VALIDATE_KOA_REQUEST_FALLBACK =
  'export function validateKoaRequest(typeName: string): (ctx: Context) => {\n  params: unknown,\n  query: unknown,\n  body: unknown,\n};';
export declare const VALIDATE_KOA_REQUEST_IMPLEMENTATION =
  "export function validateKoaRequest(typeName: string): (ctx: Context) => {\n  params: any,\n  query: any,\n  body: any,\n} {\n  const params = ajv.getSchema(`Schema#/definitions/${typeName}/properties/params`);\n  const query = ajv.getSchema(`Schema#/definitions/${typeName}/properties/query`);\n  const body = ajv.getSchema(`Schema#/definitions/${typeName}/properties/body`);\n  const validateProperty = (\n    prop: string,\n    validator: any,\n    ctx: Context,\n  ): any => {\n    const data = prop === 'body' ? ctx.request && (ctx.request as any).body : (ctx as any)[prop];\n    if (validator) {\n      const valid = validator(data);\n  \n      if (!valid) {\n        ctx.throw(\n          400,\n          'Invalid request: ' + ajv.errorsText(validator.errors, {dataVar: prop}) + '\\n\\n' + inspect({params: ctx.params, query: ctx.query, body: ctx.body}),\n        );\n      }\n    }\n    return data;\n  };\n  return (ctx) => {\n    return {\n      params: validateProperty('params', params, ctx),\n      query: validateProperty('query', query, ctx),\n      body: validateProperty('body', body, ctx),\n    }\n  };\n}";
export declare const validateOverload: (typeName: string) => string;
export declare const VALIDATE_IMPLEMENTATION =
  "export function validate(typeName: string): (value: unknown) => any {\n  const validator: any = ajv.getSchema(`Schema#/definitions/${typeName}`);\n  return (value: unknown): any => {\n    if (!validator) {\n      throw new Error(`No validator defined for Schema#/definitions/${typeName}`)\n    }\n  \n    const valid = validator(value);\n\n    if (!valid) {\n      throw new Error(\n        'Invalid ' + typeName + ': ' + ajv.errorsText(validator.errors, {dataVar: typeName}),\n      );\n    }\n\n    return value as any;\n  };\n}";
